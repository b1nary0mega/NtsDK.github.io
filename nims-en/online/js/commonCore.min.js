/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

/* eslint-disable prefer-rest-params */

((exports) => {
    function ValidationError(messageId, parameters) {
        Error.call(this, arguments);
        this.name = 'ValidationError';

        this.messageId = messageId;
        this.parameters = parameters;

        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ValidationError);
        } else {
            this.stack = (new Error()).stack;
        }
    }

    ValidationError.prototype = Object.create(Error.prototype);

    exports.ValidationError = ValidationError;

    function InternalError(messageId, parameters) {
        Error.call(this, arguments);
        this.name = 'InternalError';

        this.messageId = messageId;
        this.parameters = parameters;

        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, InternalError);
        } else {
            this.stack = (new Error()).stack;
        }
    }

    InternalError.prototype = Object.create(Error.prototype);

    exports.InternalError = InternalError;
})(typeof exports === 'undefined' ? this.Errors = {} : exports);

/*!
    EventEmitter v5.1.0 - git.io/ee
    Unlicense - http://unlicense.org/
    Oliver Caldwell - http://oli.me.uk/
    @preserve
*/
/* eslint-disable */
(function () {
    'use strict';

    function t() {} function i(t, n) { for (let e = t.length; e--;) if (t[e].listener === n) return e; return -1; } function n(e) { return function () { return this[e].apply(this, arguments); }; } let e = t.prototype, r = this, s = r.EventEmitter; e.getListeners = function (n) { let r, e, t = this._getEvents(); if (n instanceof RegExp) { r = {}; for (e in t)t.hasOwnProperty(e) && n.test(e) && (r[e] = t[e]); } else r = t[n] || (t[n] = []); return r; }, e.flattenListeners = function (t) { let e, n = []; for (e = 0; e < t.length; e += 1)n.push(t[e].listener); return n; }, e.getListenersAsObject = function (n) { let e, t = this.getListeners(n); return t instanceof Array && (e = {}, e[n] = t), e || t; }, e.addListener = function (r, e) { let t, n = this.getListenersAsObject(r), s = typeof e === 'object'; for (t in n)n.hasOwnProperty(t) && i(n[t], e) === -1 && n[t].push(s ? e : { listener: e, once: !1 }); return this; }, e.on = n('addListener'), e.addOnceListener = function (e, t) { return this.addListener(e, { listener: t, once: !0 }); }, e.once = n('addOnceListener'), e.defineEvent = function (e) { return this.getListeners(e), this; }, e.defineEvents = function (t) { for (let e = 0; e < t.length; e += 1) this.defineEvent(t[e]); return this; }, e.removeListener = function (r, s) { let n, e, t = this.getListenersAsObject(r); for (e in t)t.hasOwnProperty(e) && (n = i(t[e], s), n !== -1 && t[e].splice(n, 1)); return this; }, e.off = n('removeListener'), e.addListeners = function (e, t) { return this.manipulateListeners(!1, e, t); }, e.removeListeners = function (e, t) { return this.manipulateListeners(!0, e, t); }, e.manipulateListeners = function (r, t, i) { let e, n, s = r ? this.removeListener : this.addListener, o = r ? this.removeListeners : this.addListeners; if (typeof t !== 'object' || t instanceof RegExp) for (e = i.length; e--;)s.call(this, t, i[e]); else for (e in t)t.hasOwnProperty(e) && (n = t[e]) && (typeof n === 'function' ? s.call(this, e, n) : o.call(this, e, n)); return this; }, e.removeEvent = function (e) { let t, r = typeof e, n = this._getEvents(); if (r === 'string') delete n[e]; else if (e instanceof RegExp) for (t in n)n.hasOwnProperty(t) && e.test(t) && delete n[t]; else delete this._events; return this; }, e.removeAllListeners = n('removeEvent'), e.emitEvent = function (n, u) { let r, e, t, i, o, s = this.getListenersAsObject(n); for (i in s) if (s.hasOwnProperty(i)) for (r = s[i].slice(0), t = 0; t < r.length; t++)e = r[t], e.once === !0 && this.removeListener(n, e.listener), o = e.listener.apply(this, u || []), o === this._getOnceReturnValue() && this.removeListener(n, e.listener); return this; }, e.trigger = n('emitEvent'), e.emit = function (e) { const t = Array.prototype.slice.call(arguments, 1); return this.emitEvent(e, t); }, e.setOnceReturnValue = function (e) { return this._onceReturnValue = e, this; }, e._getOnceReturnValue = function () { return this.hasOwnProperty('_onceReturnValue') ? this._onceReturnValue : !0; }, e._getEvents = function () { return this._events || (this._events = {}); }, t.noConflict = function () { return r.EventEmitter = s, t; }, typeof define === 'function' && define.amd ? define(() => t) : typeof module === 'object' && module.exports ? module.exports = t : r.EventEmitter = t;
}).call(this);

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((callback) => {
    function CommonUtils(exports, R) {
        exports.startsWith = (str1, str2) => str1.substring(0, str2.length) === str2;

        exports.removeFromArrayByIndex = (array, from, to) => {
            const rest = array.slice((to || from) + 1 || array.length);
            array.length = from < 0 ? array.length + from : from;
            return array.push(...rest);
        };

        exports.charOrdAFactoryBase = R.curry((sortDir, greater, prepare) => function cmp(a, b) {
            a = prepare(a);
            b = prepare(b);
            if (R.isNil(a) && R.isNil(b)) return 0;
            if (R.isNil(a)) return 1;
            if (R.isNil(b)) return -1;
            if (greater(a, b)) { return sortDir === 'asc' ? 1 : -1; }
            if (greater(b, a)) { return sortDir === 'asc' ? -1 : 1; }
            return 0;
        });
        //        exports.charOrdAFactoryBase = R.curry((sortDir, prepare) => function cmp(a, b) {
        //            a = prepare(a);
        //            b = prepare(b);
        //            if (R.isNil(a) && R.isNil(b)) return 0;
        //            if (R.isNil(a)) return 1;
        //            if (R.isNil(b)) return -1;
        //            if (a > b) { return sortDir === 'asc' ? 1 : -1; }
        //            if (a < b) { return sortDir === 'asc' ? -1 : 1; }
        //            return 0;
        //        });

        exports.charOrdAFactory = exports.charOrdAFactoryBase('asc', (a, b) => a > b);

        exports.charOrdA = exports.charOrdAFactory(a => a.toLowerCase());

        exports.eventsByTime = exports.charOrdAFactory(a => new Date(a.time));

        exports.strFormat = (str, vals) => str.replace(/\{\{|\}\}|\{(\d+)\}/g, (m, n) => {
            if (m === '{{') { return '{'; }
            if (m === '}}') { return '}'; }
            return vals[n];
        });

        exports.consoleLog = str => console.log(str);
        exports.consoleErr = str => console.error(str);

        exports.clone = R.clone;

        const pregQuote = (str, delimiter) =>
            // http://kevin.vanzonneveld.net
            // + original by: booeyOH
            // + improved by: Ates Goral (http://magnetiq.com)
            // + improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // + bugfixed by: Onno Marsman
            // + improved by: Brett Zamir (http://brett-zamir.me)
            // * example 1: pregQuote("$40");
            // * returns 1: '\$40'
            // * example 2: pregQuote("*RRRING* Hello?");
            // * returns 2: '\*RRRING\* Hello\?'
            // * example 3: pregQuote("\\.+*?[^]$(){}=!<>|:");
            // * returns 3: '\\\.\+\*\?\[\^\]\$\(\)\{\}\=\!\<\>\|\:'
            (`${str}`).replace(new RegExp(`[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\${
                delimiter || ''}-]`, 'g'), '\\$&');

        exports.globStringToRegex = str => new RegExp(pregQuote(str).replace(/\\\*/g, '.*').replace(/\\\?/g, '.'), 'g');

        // taken from MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
        exports.escapeRegExp = string =>
            string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string

        exports.arr2map = (array, key) => array.reduce((a, b) => {
            a[b[key]] = b;
            return a;
        }, {});

        exports.colorPattern = /^#[0-9A-Fa-f]{6}$/;

        exports.isColor = str => exports.colorPattern.test(str);
        
        const illegalRe = /[\/\?<>\\:\*\|":]/g;
        const controlRe = /[\x00-\x1f\x80-\x9f]/g;
        const reservedRe = /^\.+$/;
        const windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
        const windowsTrailingRe = /[\. ]+$/;

        exports.sanitizeStr2FileName = (input, replacement) => {
            replacement = replacement || '';
            var sanitized = input
                .replace(illegalRe, replacement)
                .replace(controlRe, replacement)
                .replace(reservedRe, replacement)
                .replace(windowsReservedRe, replacement)
                .replace(windowsTrailingRe, replacement);
            return sanitized.substring(0, 255);
        }
    }

    callback(CommonUtils);
})(api => ((typeof exports === 'undefined') ? api((this.CommonUtils = {}), R) : (module.exports = api)));

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((callback2) => {
    function Precondition(exports, R, Errors) {
        exports.makeValidationError = (err) => {
            err.splice(0, 0, null);
            return new (Function.prototype.bind.apply(Errors.ValidationError, err))();
        };

        // precondition API
        exports.precondition = R.curry((check, reject, resolve) => {
            const err = check();
            if (err === null) {
                resolve();
            } else {
                reject(exports.makeValidationError(err));
            }
        });
        
        exports.precondition2 = R.curry((check) => {
            const err = check();
            if (err === null) {
                return Promise.resolve();
            } else {
                return Promise.reject(exports.makeValidationError(err));
            }
        });

        exports.chainCheck = R.curry(arr => () => arr.reduce((err, item) => {
            if (err) return err;
            return item();
        }, null));

        exports.eitherCheck = R.curry((func1, func2) => () => {
            const res1 = func1();
            if (res1 === null) {
                return null;
            }
            const res2 = func2();
            if (res2 === null) {
                return null;
            }
            return res1;
        });

        // primitive precondition checks
        const arrContainsElsCheck = R.curry((msg, els, valueList) => () => {
            const diff = R.difference(els, valueList);
            return diff.length === 0 ? null : [msg, [JSON.stringify(diff)]];
        });

        exports.elementsFromEnum = arrContainsElsCheck('errors-unsupported-types-in-list');
        exports.entitiesExist = arrContainsElsCheck('errors-entities-are-not-exist');

        const arrContainsElCheck = R.curry((msg, el, valueList) =>
            () => (R.contains(el, valueList) ? null : [msg, [el]]));

        exports.elementFromEnum = arrContainsElCheck('errors-unsupported-type-in-list');
        exports.entityExists = arrContainsElCheck('errors-entity-is-not-exist');

        exports.entityIsNotUsed = R.curry((el, valueList) =>
            () => (!R.contains(el, valueList) ? null : ['errors-entity-is-used', [el]]));

        exports.isString = R.curry(el =>
            () => (R.is(String, el) ? null : ['errors-argument-is-not-a-string', [el]]));

        exports.isEmptyString = R.curry(el =>
            () => (R.equals('', el) ? null : ['errors-argument-is-not-empty-string', [el]]));

        exports.isNotEmptyString = R.curry(el =>
            () => (!R.equals('', el) ? null : ['errors-argument-is-empty-string', [el]]));

        exports.nameIsNotEmpty = R.curry(el =>
            () => (!R.equals('', el) ? null : ['errors-name-is-empty-string', [el]]));
        
        exports.nameIsNotEmpty2 = R.curry((el, nameType, entityTypeKey) =>
            () => (!R.equals('', el) ? null : ['errors-name-is-empty-string2', [nameType, entityTypeKey]]));

        exports.isArray = R.curry(el =>
            () => (R.is(Array, el) ? null : ['errors-argument-is-not-an-array', [el]]));

        exports.isObject = R.curry(el =>
            () => (R.is(Object, el) ? null : ['errors-argument-is-not-an-object', [el]]));

        exports.isBoolean = R.curry(el =>
            () => (R.is(Boolean, el) ? null : ['errors-argument-is-not-a-boolean', [el]]));

        exports.isNumber = R.curry(el =>
            () => (R.is(Number, el) ? null : ['errors-argument-is-not-a-number', [el]]));

        exports.isNil = R.curry(el =>
            () => (R.isNil(el) ? null : ['errors-argument-is-not-nil', [el]]));

        exports.nil = R.curry(() => () => null);

        exports.notEquals = R.curry((el, el2) =>
            () => (!R.equals(el, el2) ? null : ['errors-argument-must-not-be-equal', [el]]));

        exports.equals = R.curry((el, el2) =>
            () => (R.equals(el, el2) ? null : ['errors-arguments-must-be-equal', [el, el2]]));

        exports.isInRange = R.curry((el, low, up) =>
            () => (low <= el && el <= up ? null : ['errors-argument-is-not-in-range', [el, low, up]]));

        exports.isNonNegative = R.curry(el =>
            () => (el >= 0 ? null : ['errors-argument-is-negative', [el]]));

        exports.createEntityCheck = R.curry((entityName, entityList) =>
            exports.chainCheck([exports.isString(entityName), exports.nameIsNotEmpty(entityName),
                exports.entityIsNotUsed(entityName, entityList)]));
        
        exports.createEntityCheck2 = R.curry((entityName, entityList, nameType, entityTypeKey) =>
            exports.chainCheck([exports.isString(entityName), exports.nameIsNotEmpty2(entityName, nameType, entityTypeKey),
                exports.entityIsNotUsed(entityName, entityList)]));

        exports.removeEntityCheck = R.curry((entityName, entityList) =>
            exports.chainCheck([exports.isString(entityName), exports.entityExists(entityName, entityList)]));

        exports.entityExistsCheck = exports.removeEntityCheck;

        exports.renameEntityCheck = R.curry((fromName, toName, entityList) =>
            exports.chainCheck([exports.removeEntityCheck(fromName, entityList),
                exports.createEntityCheck(toName, entityList)]));

        exports.switchEntityCheck = R.curry((entity1, entity2, entityList, entityContainerList) =>
            exports.chainCheck([exports.entityExistsCheck(entity1, entityList),
                exports.entityExistsCheck(entity2, entityList),
                exports.entityExists(entity1, entityContainerList),
                exports.entityIsNotUsed(entity2, entityContainerList)]));

        exports.patternCheck = R.curry((el, regex) => () =>
            (regex.test(el) ? null : ['errors-argument-doesnt-match-pattern', [el, regex.toString()]]));

        exports.arrayCheck = R.curry((arr, check) => exports.chainCheck(arr.map(check)));

        exports.getValueCheck = (type) => {
            switch (type) {
            case 'checkbox':
                return exports.isBoolean;
            case 'number':
                return exports.isNumber;
            default:
                return exports.isString;
            }
        };
    }

    callback2(Precondition);
})(api => ((typeof exports === 'undefined') ? api((this.Precondition = {}), R, Errors) : (module.exports = api)));

/*
    Date Format 1.2.3
    (c) 2007-2009 Steven Levithan <stevenlevithan.com>
    MIT license

    Includes enhancements by Scott Trenda <scott.trenda.net>
    and Kris Kowal <cixar.com/~kris.kowal/>

    Accepts a date, a mask, or a date and a mask.
    Returns a formatted version of the given date.
    The date defaults to the current date/time.
    The mask defaults to dateFormat.masks.default.
*/

// Thanks for your work ;)
// NtsDK

/* eslint-disable */

(function (callback) {
    var dateFormat = (function () {
        let token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
            timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
            timezoneClip = /[^-+\dA-Z]/g,
            pad = function (val, len) {
                val = String(val);
                len = len || 2;
                while (val.length < len) val = `0${val}`;
                return val;
            };

        // Regexes and supporting functions are cached through closure
        return function (date, mask, utc) {
            const dF = dateFormat;

            // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
            if (arguments.length == 1 && Object.prototype.toString.call(date) == '[object String]' && !/\d/.test(date)) {
                mask = date;
                date = undefined;
            }

            // Passing date through Date applies Date.parse, if necessary
            date = date ? new Date(date) : new Date();
            if (isNaN(date)) throw SyntaxError('invalid date');

            mask = String(dF.masks[mask] || mask || dF.masks.default);

            // Allow setting the utc argument via the mask
            if (mask.slice(0, 4) == 'UTC:') {
                mask = mask.slice(4);
                utc = true;
            }

            let _ = utc ? 'getUTC' : 'get',
                d = date[`${_}Date`](),
                D = date[`${_}Day`](),
                m = date[`${_}Month`](),
                y = date[`${_}FullYear`](),
                H = date[`${_}Hours`](),
                M = date[`${_}Minutes`](),
                s = date[`${_}Seconds`](),
                L = date[`${_}Milliseconds`](),
                o = utc ? 0 : date.getTimezoneOffset(),
                flags = {
                    d,
                    dd: pad(d),
                    ddd: dF.i18n.dayNames[D],
                    dddd: dF.i18n.dayNames[D + 7],
                    m: m + 1,
                    mm: pad(m + 1),
                    mmm: dF.i18n.monthNames[m],
                    mmmm: dF.i18n.monthNames[m + 12],
                    yy: String(y).slice(2),
                    yyyy: y,
                    h: H % 12 || 12,
                    hh: pad(H % 12 || 12),
                    H,
                    HH: pad(H),
                    M,
                    MM: pad(M),
                    s,
                    ss: pad(s),
                    l: pad(L, 3),
                    L: pad(L > 99 ? Math.round(L / 10) : L),
                    t: H < 12 ? 'a' : 'p',
                    tt: H < 12 ? 'am' : 'pm',
                    T: H < 12 ? 'A' : 'P',
                    TT: H < 12 ? 'AM' : 'PM',
                    Z: utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
                    o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                    S: ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
                };

            return mask.replace(token, $0 => ($0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)));
        };
    }());

    // Some common format strings
    dateFormat.masks = {
        default: 'ddd mmm dd yyyy HH:MM:ss',
        shortDate: 'm/d/yy',
        mediumDate: 'mmm d, yyyy',
        longDate: 'mmmm d, yyyy',
        fullDate: 'dddd, mmmm d, yyyy',
        shortTime: 'h:MM TT',
        mediumTime: 'h:MM:ss TT',
        longTime: 'h:MM:ss TT Z',
        isoDate: 'yyyy-mm-dd',
        isoTime: 'HH:MM:ss',
        isoDateTime: 'yyyy-mm-dd\'T\'HH:MM:ss',
        isoUtcDateTime: 'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\''
    };

    // Internationalization strings
    dateFormat.i18n = {
        dayNames: [
            'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
            'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
        ],
        monthNames: [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
            'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
        ]
    };

    callback(dateFormat);
}(dateFormat => ((typeof exports === 'undefined') ? (this.dateFormat = dateFormat) : (module.exports = dateFormat))));

var defaultLang = 'en';

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvcmUvanMvY29tbW9uL2Vycm9ycy5qcyIsIi4uL2NvcmUvanMvY29tbW9uL0V2ZW50RW1pdHRlci5qcyIsIi4uL2NvcmUvanMvY29tbW9uL2NvbW1vblV0aWxzLmpzIiwiLi4vY29yZS9qcy9jb21tb24vcHJlY29uZGl0aW9uLmpzIiwiLi4vY29yZS9qcy9jb21tb24vZGF0ZUZvcm1hdC5qcyIsIi4uLy4uLy4uLy4uL3NtdGstbmltcy10cmFuc2xhdGlvbnMvbmltcy9lbi9kZWZhdWx0TGFuZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvSEE7QUFDQSIsImZpbGUiOiJjb21tb25Db3JlLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qQ29weXJpZ2h0IDIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cclxuXHJcbigoZXhwb3J0cykgPT4ge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2VJZCwgcGFyYW1ldGVycykge1xyXG4gICAgICAgIEVycm9yLmNhbGwodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcclxuXHJcbiAgICAgICAgdGhpcy5tZXNzYWdlSWQgPSBtZXNzYWdlSWQ7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcclxuXHJcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcblxyXG4gICAgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3I7XHJcblxyXG4gICAgZnVuY3Rpb24gSW50ZXJuYWxFcnJvcihtZXNzYWdlSWQsIHBhcmFtZXRlcnMpIHtcclxuICAgICAgICBFcnJvci5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludGVybmFsRXJyb3InO1xyXG5cclxuICAgICAgICB0aGlzLm1lc3NhZ2VJZCA9IG1lc3NhZ2VJZDtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xyXG5cclxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW50ZXJuYWxFcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEludGVybmFsRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGV4cG9ydHMuSW50ZXJuYWxFcnJvciA9IEludGVybmFsRXJyb3I7XHJcbn0pKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHRoaXMuRXJyb3JzID0ge30gOiBleHBvcnRzKTtcclxuIiwiLyohXHJcbiAgICBFdmVudEVtaXR0ZXIgdjUuMS4wIC0gZ2l0LmlvL2VlXHJcbiAgICBVbmxpY2Vuc2UgLSBodHRwOi8vdW5saWNlbnNlLm9yZy9cclxuICAgIE9saXZlciBDYWxkd2VsbCAtIGh0dHA6Ly9vbGkubWUudWsvXHJcbiAgICBAcHJlc2VydmVcclxuKi9cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBmdW5jdGlvbiB0KCkge30gZnVuY3Rpb24gaSh0LCBuKSB7IGZvciAobGV0IGUgPSB0Lmxlbmd0aDsgZS0tOykgaWYgKHRbZV0ubGlzdGVuZXIgPT09IG4pIHJldHVybiBlOyByZXR1cm4gLTE7IH0gZnVuY3Rpb24gbihlKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2VdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07IH0gbGV0IGUgPSB0LnByb3RvdHlwZSwgciA9IHRoaXMsIHMgPSByLkV2ZW50RW1pdHRlcjsgZS5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobikgeyBsZXQgciwgZSwgdCA9IHRoaXMuX2dldEV2ZW50cygpOyBpZiAobiBpbnN0YW5jZW9mIFJlZ0V4cCkgeyByID0ge307IGZvciAoZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkgJiYgbi50ZXN0KGUpICYmIChyW2VdID0gdFtlXSk7IH0gZWxzZSByID0gdFtuXSB8fCAodFtuXSA9IFtdKTsgcmV0dXJuIHI7IH0sIGUuZmxhdHRlbkxpc3RlbmVycyA9IGZ1bmN0aW9uICh0KSB7IGxldCBlLCBuID0gW107IGZvciAoZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSArPSAxKW4ucHVzaCh0W2VdLmxpc3RlbmVyKTsgcmV0dXJuIG47IH0sIGUuZ2V0TGlzdGVuZXJzQXNPYmplY3QgPSBmdW5jdGlvbiAobikgeyBsZXQgZSwgdCA9IHRoaXMuZ2V0TGlzdGVuZXJzKG4pOyByZXR1cm4gdCBpbnN0YW5jZW9mIEFycmF5ICYmIChlID0ge30sIGVbbl0gPSB0KSwgZSB8fCB0OyB9LCBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKHIsIGUpIHsgbGV0IHQsIG4gPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KHIpLCBzID0gdHlwZW9mIGUgPT09ICdvYmplY3QnOyBmb3IgKHQgaW4gbiluLmhhc093blByb3BlcnR5KHQpICYmIGkoblt0XSwgZSkgPT09IC0xICYmIG5bdF0ucHVzaChzID8gZSA6IHsgbGlzdGVuZXI6IGUsIG9uY2U6ICExIH0pOyByZXR1cm4gdGhpczsgfSwgZS5vbiA9IG4oJ2FkZExpc3RlbmVyJyksIGUuYWRkT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZSwgeyBsaXN0ZW5lcjogdCwgb25jZTogITAgfSk7IH0sIGUub25jZSA9IG4oJ2FkZE9uY2VMaXN0ZW5lcicpLCBlLmRlZmluZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRoaXMuZ2V0TGlzdGVuZXJzKGUpLCB0aGlzOyB9LCBlLmRlZmluZUV2ZW50cyA9IGZ1bmN0aW9uICh0KSB7IGZvciAobGV0IGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUgKz0gMSkgdGhpcy5kZWZpbmVFdmVudCh0W2VdKTsgcmV0dXJuIHRoaXM7IH0sIGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAociwgcykgeyBsZXQgbiwgZSwgdCA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3Qocik7IGZvciAoZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkgJiYgKG4gPSBpKHRbZV0sIHMpLCBuICE9PSAtMSAmJiB0W2VdLnNwbGljZShuLCAxKSk7IHJldHVybiB0aGlzOyB9LCBlLm9mZiA9IG4oJ3JlbW92ZUxpc3RlbmVyJyksIGUuYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyghMSwgZSwgdCk7IH0sIGUucmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyghMCwgZSwgdCk7IH0sIGUubWFuaXB1bGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIChyLCB0LCBpKSB7IGxldCBlLCBuLCBzID0gciA/IHRoaXMucmVtb3ZlTGlzdGVuZXIgOiB0aGlzLmFkZExpc3RlbmVyLCBvID0gciA/IHRoaXMucmVtb3ZlTGlzdGVuZXJzIDogdGhpcy5hZGRMaXN0ZW5lcnM7IGlmICh0eXBlb2YgdCAhPT0gJ29iamVjdCcgfHwgdCBpbnN0YW5jZW9mIFJlZ0V4cCkgZm9yIChlID0gaS5sZW5ndGg7IGUtLTspcy5jYWxsKHRoaXMsIHQsIGlbZV0pOyBlbHNlIGZvciAoZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkgJiYgKG4gPSB0W2VdKSAmJiAodHlwZW9mIG4gPT09ICdmdW5jdGlvbicgPyBzLmNhbGwodGhpcywgZSwgbikgOiBvLmNhbGwodGhpcywgZSwgbikpOyByZXR1cm4gdGhpczsgfSwgZS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlKSB7IGxldCB0LCByID0gdHlwZW9mIGUsIG4gPSB0aGlzLl9nZXRFdmVudHMoKTsgaWYgKHIgPT09ICdzdHJpbmcnKSBkZWxldGUgbltlXTsgZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFJlZ0V4cCkgZm9yICh0IGluIG4pbi5oYXNPd25Qcm9wZXJ0eSh0KSAmJiBlLnRlc3QodCkgJiYgZGVsZXRlIG5bdF07IGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50czsgcmV0dXJuIHRoaXM7IH0sIGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gbigncmVtb3ZlRXZlbnQnKSwgZS5lbWl0RXZlbnQgPSBmdW5jdGlvbiAobiwgdSkgeyBsZXQgciwgZSwgdCwgaSwgbywgcyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3Qobik7IGZvciAoaSBpbiBzKSBpZiAocy5oYXNPd25Qcm9wZXJ0eShpKSkgZm9yIChyID0gc1tpXS5zbGljZSgwKSwgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKWUgPSByW3RdLCBlLm9uY2UgPT09ICEwICYmIHRoaXMucmVtb3ZlTGlzdGVuZXIobiwgZS5saXN0ZW5lciksIG8gPSBlLmxpc3RlbmVyLmFwcGx5KHRoaXMsIHUgfHwgW10pLCBvID09PSB0aGlzLl9nZXRPbmNlUmV0dXJuVmFsdWUoKSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKG4sIGUubGlzdGVuZXIpOyByZXR1cm4gdGhpczsgfSwgZS50cmlnZ2VyID0gbignZW1pdEV2ZW50JyksIGUuZW1pdCA9IGZ1bmN0aW9uIChlKSB7IGNvbnN0IHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyByZXR1cm4gdGhpcy5lbWl0RXZlbnQoZSwgdCk7IH0sIGUuc2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRoaXMuX29uY2VSZXR1cm5WYWx1ZSA9IGUsIHRoaXM7IH0sIGUuX2dldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaGFzT3duUHJvcGVydHkoJ19vbmNlUmV0dXJuVmFsdWUnKSA/IHRoaXMuX29uY2VSZXR1cm5WYWx1ZSA6ICEwOyB9LCBlLl9nZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTsgfSwgdC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gci5FdmVudEVtaXR0ZXIgPSBzLCB0OyB9LCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoKCkgPT4gdCkgOiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzID0gdCA6IHIuRXZlbnRFbWl0dGVyID0gdDtcclxufSkuY2FsbCh0aGlzKTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbigoY2FsbGJhY2spID0+IHtcclxuICAgIGZ1bmN0aW9uIENvbW1vblV0aWxzKGV4cG9ydHMsIFIpIHtcclxuICAgICAgICBleHBvcnRzLnN0YXJ0c1dpdGggPSAoc3RyMSwgc3RyMikgPT4gc3RyMS5zdWJzdHJpbmcoMCwgc3RyMi5sZW5ndGgpID09PSBzdHIyO1xyXG5cclxuICAgICAgICBleHBvcnRzLnJlbW92ZUZyb21BcnJheUJ5SW5kZXggPSAoYXJyYXksIGZyb20sIHRvKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBhcnJheS5zbGljZSgodG8gfHwgZnJvbSkgKyAxIHx8IGFycmF5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGFycmF5Lmxlbmd0aCA9IGZyb20gPCAwID8gYXJyYXkubGVuZ3RoICsgZnJvbSA6IGZyb207XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5wdXNoKC4uLnJlc3QpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGV4cG9ydHMuY2hhck9yZEFGYWN0b3J5QmFzZSA9IFIuY3VycnkoKHNvcnREaXIsIGdyZWF0ZXIsIHByZXBhcmUpID0+IGZ1bmN0aW9uIGNtcChhLCBiKSB7XHJcbiAgICAgICAgICAgIGEgPSBwcmVwYXJlKGEpO1xyXG4gICAgICAgICAgICBiID0gcHJlcGFyZShiKTtcclxuICAgICAgICAgICAgaWYgKFIuaXNOaWwoYSkgJiYgUi5pc05pbChiKSkgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGlmIChSLmlzTmlsKGEpKSByZXR1cm4gMTtcclxuICAgICAgICAgICAgaWYgKFIuaXNOaWwoYikpIHJldHVybiAtMTtcclxuICAgICAgICAgICAgaWYgKGdyZWF0ZXIoYSwgYikpIHsgcmV0dXJuIHNvcnREaXIgPT09ICdhc2MnID8gMSA6IC0xOyB9XHJcbiAgICAgICAgICAgIGlmIChncmVhdGVyKGIsIGEpKSB7IHJldHVybiBzb3J0RGlyID09PSAnYXNjJyA/IC0xIDogMTsgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyAgICAgICAgZXhwb3J0cy5jaGFyT3JkQUZhY3RvcnlCYXNlID0gUi5jdXJyeSgoc29ydERpciwgcHJlcGFyZSkgPT4gZnVuY3Rpb24gY21wKGEsIGIpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgIGEgPSBwcmVwYXJlKGEpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgYiA9IHByZXBhcmUoYik7XHJcbiAgICAgICAgLy8gICAgICAgICAgICBpZiAoUi5pc05pbChhKSAmJiBSLmlzTmlsKGIpKSByZXR1cm4gMDtcclxuICAgICAgICAvLyAgICAgICAgICAgIGlmIChSLmlzTmlsKGEpKSByZXR1cm4gMTtcclxuICAgICAgICAvLyAgICAgICAgICAgIGlmIChSLmlzTmlsKGIpKSByZXR1cm4gLTE7XHJcbiAgICAgICAgLy8gICAgICAgICAgICBpZiAoYSA+IGIpIHsgcmV0dXJuIHNvcnREaXIgPT09ICdhc2MnID8gMSA6IC0xOyB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICBpZiAoYSA8IGIpIHsgcmV0dXJuIHNvcnREaXIgPT09ICdhc2MnID8gLTEgOiAxOyB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAvLyAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuY2hhck9yZEFGYWN0b3J5ID0gZXhwb3J0cy5jaGFyT3JkQUZhY3RvcnlCYXNlKCdhc2MnLCAoYSwgYikgPT4gYSA+IGIpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmNoYXJPcmRBID0gZXhwb3J0cy5jaGFyT3JkQUZhY3RvcnkoYSA9PiBhLnRvTG93ZXJDYXNlKCkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmV2ZW50c0J5VGltZSA9IGV4cG9ydHMuY2hhck9yZEFGYWN0b3J5KGEgPT4gbmV3IERhdGUoYS50aW1lKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuc3RyRm9ybWF0ID0gKHN0ciwgdmFscykgPT4gc3RyLnJlcGxhY2UoL1xce1xce3xcXH1cXH18XFx7KFxcZCspXFx9L2csIChtLCBuKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtID09PSAne3snKSB7IHJldHVybiAneyc7IH1cclxuICAgICAgICAgICAgaWYgKG0gPT09ICd9fScpIHsgcmV0dXJuICd9JzsgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsc1tuXTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5jb25zb2xlTG9nID0gc3RyID0+IGNvbnNvbGUubG9nKHN0cik7XHJcbiAgICAgICAgZXhwb3J0cy5jb25zb2xlRXJyID0gc3RyID0+IGNvbnNvbGUuZXJyb3Ioc3RyKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5jbG9uZSA9IFIuY2xvbmU7XHJcblxyXG4gICAgICAgIGNvbnN0IHByZWdRdW90ZSA9IChzdHIsIGRlbGltaXRlcikgPT5cclxuICAgICAgICAgICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcclxuICAgICAgICAgICAgLy8gKyBvcmlnaW5hbCBieTogYm9vZXlPSFxyXG4gICAgICAgICAgICAvLyArIGltcHJvdmVkIGJ5OiBBdGVzIEdvcmFsIChodHRwOi8vbWFnbmV0aXEuY29tKVxyXG4gICAgICAgICAgICAvLyArIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcclxuICAgICAgICAgICAgLy8gKyBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXHJcbiAgICAgICAgICAgIC8vICsgaW1wcm92ZWQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXHJcbiAgICAgICAgICAgIC8vICogZXhhbXBsZSAxOiBwcmVnUXVvdGUoXCIkNDBcIik7XHJcbiAgICAgICAgICAgIC8vICogcmV0dXJucyAxOiAnXFwkNDAnXHJcbiAgICAgICAgICAgIC8vICogZXhhbXBsZSAyOiBwcmVnUXVvdGUoXCIqUlJSSU5HKiBIZWxsbz9cIik7XHJcbiAgICAgICAgICAgIC8vICogcmV0dXJucyAyOiAnXFwqUlJSSU5HXFwqIEhlbGxvXFw/J1xyXG4gICAgICAgICAgICAvLyAqIGV4YW1wbGUgMzogcHJlZ1F1b3RlKFwiXFxcXC4rKj9bXl0kKCl7fT0hPD58OlwiKTtcclxuICAgICAgICAgICAgLy8gKiByZXR1cm5zIDM6ICdcXFxcXFwuXFwrXFwqXFw/XFxbXFxeXFxdXFwkXFwoXFwpXFx7XFx9XFw9XFwhXFw8XFw+XFx8XFw6J1xyXG4gICAgICAgICAgICAoYCR7c3RyfWApLnJlcGxhY2UobmV3IFJlZ0V4cChgWy5cXFxcXFxcXCsqP1xcXFxbXFxcXF5cXFxcXSQoKXt9PSE8Pnw6XFxcXCR7XHJcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgfHwgJyd9LV1gLCAnZycpLCAnXFxcXCQmJyk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuZ2xvYlN0cmluZ1RvUmVnZXggPSBzdHIgPT4gbmV3IFJlZ0V4cChwcmVnUXVvdGUoc3RyKS5yZXBsYWNlKC9cXFxcXFwqL2csICcuKicpLnJlcGxhY2UoL1xcXFxcXD8vZywgJy4nKSwgJ2cnKTtcclxuXHJcbiAgICAgICAgLy8gdGFrZW4gZnJvbSBNRE4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zXHJcbiAgICAgICAgZXhwb3J0cy5lc2NhcGVSZWdFeHAgPSBzdHJpbmcgPT5cclxuICAgICAgICAgICAgc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xyXG5cclxuICAgICAgICBleHBvcnRzLmFycjJtYXAgPSAoYXJyYXksIGtleSkgPT4gYXJyYXkucmVkdWNlKChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGFbYltrZXldXSA9IGI7XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH0sIHt9KTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5jb2xvclBhdHRlcm4gPSAvXiNbMC05QS1GYS1mXXs2fSQvO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzQ29sb3IgPSBzdHIgPT4gZXhwb3J0cy5jb2xvclBhdHRlcm4udGVzdChzdHIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGlsbGVnYWxSZSA9IC9bXFwvXFw/PD5cXFxcOlxcKlxcfFwiOl0vZztcclxuICAgICAgICBjb25zdCBjb250cm9sUmUgPSAvW1xceDAwLVxceDFmXFx4ODAtXFx4OWZdL2c7XHJcbiAgICAgICAgY29uc3QgcmVzZXJ2ZWRSZSA9IC9eXFwuKyQvO1xyXG4gICAgICAgIGNvbnN0IHdpbmRvd3NSZXNlcnZlZFJlID0gL14oY29ufHBybnxhdXh8bnVsfGNvbVswLTldfGxwdFswLTldKShcXC4uKik/JC9pO1xyXG4gICAgICAgIGNvbnN0IHdpbmRvd3NUcmFpbGluZ1JlID0gL1tcXC4gXSskLztcclxuXHJcbiAgICAgICAgZXhwb3J0cy5zYW5pdGl6ZVN0cjJGaWxlTmFtZSA9IChpbnB1dCwgcmVwbGFjZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudCB8fCAnJztcclxuICAgICAgICAgICAgdmFyIHNhbml0aXplZCA9IGlucHV0XHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShpbGxlZ2FsUmUsIHJlcGxhY2VtZW50KVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoY29udHJvbFJlLCByZXBsYWNlbWVudClcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJlc2VydmVkUmUsIHJlcGxhY2VtZW50KVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2Uod2luZG93c1Jlc2VydmVkUmUsIHJlcGxhY2VtZW50KVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2Uod2luZG93c1RyYWlsaW5nUmUsIHJlcGxhY2VtZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNhbml0aXplZC5zdWJzdHJpbmcoMCwgMjU1KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2FsbGJhY2soQ29tbW9uVXRpbHMpO1xyXG59KShhcGkgPT4gKCh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcpID8gYXBpKCh0aGlzLkNvbW1vblV0aWxzID0ge30pLCBSKSA6IChtb2R1bGUuZXhwb3J0cyA9IGFwaSkpKTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbigoY2FsbGJhY2syKSA9PiB7XHJcbiAgICBmdW5jdGlvbiBQcmVjb25kaXRpb24oZXhwb3J0cywgUiwgRXJyb3JzKSB7XHJcbiAgICAgICAgZXhwb3J0cy5tYWtlVmFsaWRhdGlvbkVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICBlcnIuc3BsaWNlKDAsIDAsIG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShFcnJvcnMuVmFsaWRhdGlvbkVycm9yLCBlcnIpKSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHByZWNvbmRpdGlvbiBBUElcclxuICAgICAgICBleHBvcnRzLnByZWNvbmRpdGlvbiA9IFIuY3VycnkoKGNoZWNrLCByZWplY3QsIHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXJyID0gY2hlY2soKTtcclxuICAgICAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGV4cG9ydHMubWFrZVZhbGlkYXRpb25FcnJvcihlcnIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGV4cG9ydHMucHJlY29uZGl0aW9uMiA9IFIuY3VycnkoKGNoZWNrKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGNoZWNrKCk7XHJcbiAgICAgICAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleHBvcnRzLm1ha2VWYWxpZGF0aW9uRXJyb3IoZXJyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5jaGFpbkNoZWNrID0gUi5jdXJyeShhcnIgPT4gKCkgPT4gYXJyLnJlZHVjZSgoZXJyLCBpdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBlcnI7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtKCk7XHJcbiAgICAgICAgfSwgbnVsbCkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmVpdGhlckNoZWNrID0gUi5jdXJyeSgoZnVuYzEsIGZ1bmMyKSA9PiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlczEgPSBmdW5jMSgpO1xyXG4gICAgICAgICAgICBpZiAocmVzMSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzMiA9IGZ1bmMyKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXMyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzMTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gcHJpbWl0aXZlIHByZWNvbmRpdGlvbiBjaGVja3NcclxuICAgICAgICBjb25zdCBhcnJDb250YWluc0Vsc0NoZWNrID0gUi5jdXJyeSgobXNnLCBlbHMsIHZhbHVlTGlzdCkgPT4gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gUi5kaWZmZXJlbmNlKGVscywgdmFsdWVMaXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpZmYubGVuZ3RoID09PSAwID8gbnVsbCA6IFttc2csIFtKU09OLnN0cmluZ2lmeShkaWZmKV1dO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBleHBvcnRzLmVsZW1lbnRzRnJvbUVudW0gPSBhcnJDb250YWluc0Vsc0NoZWNrKCdlcnJvcnMtdW5zdXBwb3J0ZWQtdHlwZXMtaW4tbGlzdCcpO1xyXG4gICAgICAgIGV4cG9ydHMuZW50aXRpZXNFeGlzdCA9IGFyckNvbnRhaW5zRWxzQ2hlY2soJ2Vycm9ycy1lbnRpdGllcy1hcmUtbm90LWV4aXN0Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGFyckNvbnRhaW5zRWxDaGVjayA9IFIuY3VycnkoKG1zZywgZWwsIHZhbHVlTGlzdCkgPT5cclxuICAgICAgICAgICAgKCkgPT4gKFIuY29udGFpbnMoZWwsIHZhbHVlTGlzdCkgPyBudWxsIDogW21zZywgW2VsXV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5lbGVtZW50RnJvbUVudW0gPSBhcnJDb250YWluc0VsQ2hlY2soJ2Vycm9ycy11bnN1cHBvcnRlZC10eXBlLWluLWxpc3QnKTtcclxuICAgICAgICBleHBvcnRzLmVudGl0eUV4aXN0cyA9IGFyckNvbnRhaW5zRWxDaGVjaygnZXJyb3JzLWVudGl0eS1pcy1ub3QtZXhpc3QnKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5lbnRpdHlJc05vdFVzZWQgPSBSLmN1cnJ5KChlbCwgdmFsdWVMaXN0KSA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoIVIuY29udGFpbnMoZWwsIHZhbHVlTGlzdCkgPyBudWxsIDogWydlcnJvcnMtZW50aXR5LWlzLXVzZWQnLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzU3RyaW5nID0gUi5jdXJyeShlbCA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoUi5pcyhTdHJpbmcsIGVsKSA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1pcy1ub3QtYS1zdHJpbmcnLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzRW1wdHlTdHJpbmcgPSBSLmN1cnJ5KGVsID0+XHJcbiAgICAgICAgICAgICgpID0+IChSLmVxdWFscygnJywgZWwpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LWlzLW5vdC1lbXB0eS1zdHJpbmcnLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzTm90RW1wdHlTdHJpbmcgPSBSLmN1cnJ5KGVsID0+XHJcbiAgICAgICAgICAgICgpID0+ICghUi5lcXVhbHMoJycsIGVsKSA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1pcy1lbXB0eS1zdHJpbmcnLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLm5hbWVJc05vdEVtcHR5ID0gUi5jdXJyeShlbCA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoIVIuZXF1YWxzKCcnLCBlbCkgPyBudWxsIDogWydlcnJvcnMtbmFtZS1pcy1lbXB0eS1zdHJpbmcnLCBbZWxdXSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGV4cG9ydHMubmFtZUlzTm90RW1wdHkyID0gUi5jdXJyeSgoZWwsIG5hbWVUeXBlLCBlbnRpdHlUeXBlS2V5KSA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoIVIuZXF1YWxzKCcnLCBlbCkgPyBudWxsIDogWydlcnJvcnMtbmFtZS1pcy1lbXB0eS1zdHJpbmcyJywgW25hbWVUeXBlLCBlbnRpdHlUeXBlS2V5XV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5pc0FycmF5ID0gUi5jdXJyeShlbCA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoUi5pcyhBcnJheSwgZWwpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LWlzLW5vdC1hbi1hcnJheScsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNPYmplY3QgPSBSLmN1cnJ5KGVsID0+XHJcbiAgICAgICAgICAgICgpID0+IChSLmlzKE9iamVjdCwgZWwpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LWlzLW5vdC1hbi1vYmplY3QnLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzQm9vbGVhbiA9IFIuY3VycnkoZWwgPT5cclxuICAgICAgICAgICAgKCkgPT4gKFIuaXMoQm9vbGVhbiwgZWwpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LWlzLW5vdC1hLWJvb2xlYW4nLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzTnVtYmVyID0gUi5jdXJyeShlbCA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoUi5pcyhOdW1iZXIsIGVsKSA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1pcy1ub3QtYS1udW1iZXInLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzTmlsID0gUi5jdXJyeShlbCA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoUi5pc05pbChlbCkgPyBudWxsIDogWydlcnJvcnMtYXJndW1lbnQtaXMtbm90LW5pbCcsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMubmlsID0gUi5jdXJyeSgoKSA9PiAoKSA9PiBudWxsKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5ub3RFcXVhbHMgPSBSLmN1cnJ5KChlbCwgZWwyKSA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoIVIuZXF1YWxzKGVsLCBlbDIpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LW11c3Qtbm90LWJlLWVxdWFsJywgW2VsXV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5lcXVhbHMgPSBSLmN1cnJ5KChlbCwgZWwyKSA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoUi5lcXVhbHMoZWwsIGVsMikgPyBudWxsIDogWydlcnJvcnMtYXJndW1lbnRzLW11c3QtYmUtZXF1YWwnLCBbZWwsIGVsMl1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNJblJhbmdlID0gUi5jdXJyeSgoZWwsIGxvdywgdXApID0+XHJcbiAgICAgICAgICAgICgpID0+IChsb3cgPD0gZWwgJiYgZWwgPD0gdXAgPyBudWxsIDogWydlcnJvcnMtYXJndW1lbnQtaXMtbm90LWluLXJhbmdlJywgW2VsLCBsb3csIHVwXV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5pc05vbk5lZ2F0aXZlID0gUi5jdXJyeShlbCA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoZWwgPj0gMCA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1pcy1uZWdhdGl2ZScsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuY3JlYXRlRW50aXR5Q2hlY2sgPSBSLmN1cnJ5KChlbnRpdHlOYW1lLCBlbnRpdHlMaXN0KSA9PlxyXG4gICAgICAgICAgICBleHBvcnRzLmNoYWluQ2hlY2soW2V4cG9ydHMuaXNTdHJpbmcoZW50aXR5TmFtZSksIGV4cG9ydHMubmFtZUlzTm90RW1wdHkoZW50aXR5TmFtZSksXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLmVudGl0eUlzTm90VXNlZChlbnRpdHlOYW1lLCBlbnRpdHlMaXN0KV0pKTtcclxuICAgICAgICBcclxuICAgICAgICBleHBvcnRzLmNyZWF0ZUVudGl0eUNoZWNrMiA9IFIuY3VycnkoKGVudGl0eU5hbWUsIGVudGl0eUxpc3QsIG5hbWVUeXBlLCBlbnRpdHlUeXBlS2V5KSA9PlxyXG4gICAgICAgICAgICBleHBvcnRzLmNoYWluQ2hlY2soW2V4cG9ydHMuaXNTdHJpbmcoZW50aXR5TmFtZSksIGV4cG9ydHMubmFtZUlzTm90RW1wdHkyKGVudGl0eU5hbWUsIG5hbWVUeXBlLCBlbnRpdHlUeXBlS2V5KSxcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuZW50aXR5SXNOb3RVc2VkKGVudGl0eU5hbWUsIGVudGl0eUxpc3QpXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLnJlbW92ZUVudGl0eUNoZWNrID0gUi5jdXJyeSgoZW50aXR5TmFtZSwgZW50aXR5TGlzdCkgPT5cclxuICAgICAgICAgICAgZXhwb3J0cy5jaGFpbkNoZWNrKFtleHBvcnRzLmlzU3RyaW5nKGVudGl0eU5hbWUpLCBleHBvcnRzLmVudGl0eUV4aXN0cyhlbnRpdHlOYW1lLCBlbnRpdHlMaXN0KV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5lbnRpdHlFeGlzdHNDaGVjayA9IGV4cG9ydHMucmVtb3ZlRW50aXR5Q2hlY2s7XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVuYW1lRW50aXR5Q2hlY2sgPSBSLmN1cnJ5KChmcm9tTmFtZSwgdG9OYW1lLCBlbnRpdHlMaXN0KSA9PlxyXG4gICAgICAgICAgICBleHBvcnRzLmNoYWluQ2hlY2soW2V4cG9ydHMucmVtb3ZlRW50aXR5Q2hlY2soZnJvbU5hbWUsIGVudGl0eUxpc3QpLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5jcmVhdGVFbnRpdHlDaGVjayh0b05hbWUsIGVudGl0eUxpc3QpXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLnN3aXRjaEVudGl0eUNoZWNrID0gUi5jdXJyeSgoZW50aXR5MSwgZW50aXR5MiwgZW50aXR5TGlzdCwgZW50aXR5Q29udGFpbmVyTGlzdCkgPT5cclxuICAgICAgICAgICAgZXhwb3J0cy5jaGFpbkNoZWNrKFtleHBvcnRzLmVudGl0eUV4aXN0c0NoZWNrKGVudGl0eTEsIGVudGl0eUxpc3QpLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5lbnRpdHlFeGlzdHNDaGVjayhlbnRpdHkyLCBlbnRpdHlMaXN0KSxcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuZW50aXR5RXhpc3RzKGVudGl0eTEsIGVudGl0eUNvbnRhaW5lckxpc3QpLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5lbnRpdHlJc05vdFVzZWQoZW50aXR5MiwgZW50aXR5Q29udGFpbmVyTGlzdCldKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMucGF0dGVybkNoZWNrID0gUi5jdXJyeSgoZWwsIHJlZ2V4KSA9PiAoKSA9PlxyXG4gICAgICAgICAgICAocmVnZXgudGVzdChlbCkgPyBudWxsIDogWydlcnJvcnMtYXJndW1lbnQtZG9lc250LW1hdGNoLXBhdHRlcm4nLCBbZWwsIHJlZ2V4LnRvU3RyaW5nKCldXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmFycmF5Q2hlY2sgPSBSLmN1cnJ5KChhcnIsIGNoZWNrKSA9PiBleHBvcnRzLmNoYWluQ2hlY2soYXJyLm1hcChjaGVjaykpKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5nZXRWYWx1ZUNoZWNrID0gKHR5cGUpID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmlzQm9vbGVhbjtcclxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmlzTnVtYmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNTdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNhbGxiYWNrMihQcmVjb25kaXRpb24pO1xyXG59KShhcGkgPT4gKCh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcpID8gYXBpKCh0aGlzLlByZWNvbmRpdGlvbiA9IHt9KSwgUiwgRXJyb3JzKSA6IChtb2R1bGUuZXhwb3J0cyA9IGFwaSkpKTtcclxuIiwiLypcclxuICAgIERhdGUgRm9ybWF0IDEuMi4zXHJcbiAgICAoYykgMjAwNy0yMDA5IFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxyXG4gICAgTUlUIGxpY2Vuc2VcclxuXHJcbiAgICBJbmNsdWRlcyBlbmhhbmNlbWVudHMgYnkgU2NvdHQgVHJlbmRhIDxzY290dC50cmVuZGEubmV0PlxyXG4gICAgYW5kIEtyaXMgS293YWwgPGNpeGFyLmNvbS9+a3Jpcy5rb3dhbC8+XHJcblxyXG4gICAgQWNjZXB0cyBhIGRhdGUsIGEgbWFzaywgb3IgYSBkYXRlIGFuZCBhIG1hc2suXHJcbiAgICBSZXR1cm5zIGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICBUaGUgZGF0ZSBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBkYXRlL3RpbWUuXHJcbiAgICBUaGUgbWFzayBkZWZhdWx0cyB0byBkYXRlRm9ybWF0Lm1hc2tzLmRlZmF1bHQuXHJcbiovXHJcblxyXG4vLyBUaGFua3MgZm9yIHlvdXIgd29yayA7KVxyXG4vLyBOdHNES1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuXHJcbihmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIHZhciBkYXRlRm9ybWF0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgdG9rZW4gPSAvZHsxLDR9fG17MSw0fXx5eSg/Onl5KT98KFtIaE1zVHRdKVxcMT98W0xsb1NaXXxcIlteXCJdKlwifCdbXiddKicvZyxcclxuICAgICAgICAgICAgdGltZXpvbmUgPSAvXFxiKD86W1BNQ0VBXVtTRFBdVHwoPzpQYWNpZmljfE1vdW50YWlufENlbnRyYWx8RWFzdGVybnxBdGxhbnRpYykgKD86U3RhbmRhcmR8RGF5bGlnaHR8UHJldmFpbGluZykgVGltZXwoPzpHTVR8VVRDKSg/OlstK11cXGR7NH0pPylcXGIvZyxcclxuICAgICAgICAgICAgdGltZXpvbmVDbGlwID0gL1teLStcXGRBLVpdL2csXHJcbiAgICAgICAgICAgIHBhZCA9IGZ1bmN0aW9uICh2YWwsIGxlbikge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gU3RyaW5nKHZhbCk7XHJcbiAgICAgICAgICAgICAgICBsZW4gPSBsZW4gfHwgMjtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh2YWwubGVuZ3RoIDwgbGVuKSB2YWwgPSBgMCR7dmFsfWA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBSZWdleGVzIGFuZCBzdXBwb3J0aW5nIGZ1bmN0aW9ucyBhcmUgY2FjaGVkIHRocm91Z2ggY2xvc3VyZVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgbWFzaywgdXRjKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRGID0gZGF0ZUZvcm1hdDtcclxuXHJcbiAgICAgICAgICAgIC8vIFlvdSBjYW4ndCBwcm92aWRlIHV0YyBpZiB5b3Ugc2tpcCBvdGhlciBhcmdzICh1c2UgdGhlIFwiVVRDOlwiIG1hc2sgcHJlZml4KVxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRlKSA9PSAnW29iamVjdCBTdHJpbmddJyAmJiAhL1xcZC8udGVzdChkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgbWFzayA9IGRhdGU7XHJcbiAgICAgICAgICAgICAgICBkYXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQYXNzaW5nIGRhdGUgdGhyb3VnaCBEYXRlIGFwcGxpZXMgRGF0ZS5wYXJzZSwgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIGRhdGUgPSBkYXRlID8gbmV3IERhdGUoZGF0ZSkgOiBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4oZGF0ZSkpIHRocm93IFN5bnRheEVycm9yKCdpbnZhbGlkIGRhdGUnKTtcclxuXHJcbiAgICAgICAgICAgIG1hc2sgPSBTdHJpbmcoZEYubWFza3NbbWFza10gfHwgbWFzayB8fCBkRi5tYXNrcy5kZWZhdWx0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IHNldHRpbmcgdGhlIHV0YyBhcmd1bWVudCB2aWEgdGhlIG1hc2tcclxuICAgICAgICAgICAgaWYgKG1hc2suc2xpY2UoMCwgNCkgPT0gJ1VUQzonKSB7XHJcbiAgICAgICAgICAgICAgICBtYXNrID0gbWFzay5zbGljZSg0KTtcclxuICAgICAgICAgICAgICAgIHV0YyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBfID0gdXRjID8gJ2dldFVUQycgOiAnZ2V0JyxcclxuICAgICAgICAgICAgICAgIGQgPSBkYXRlW2Ake199RGF0ZWBdKCksXHJcbiAgICAgICAgICAgICAgICBEID0gZGF0ZVtgJHtffURheWBdKCksXHJcbiAgICAgICAgICAgICAgICBtID0gZGF0ZVtgJHtffU1vbnRoYF0oKSxcclxuICAgICAgICAgICAgICAgIHkgPSBkYXRlW2Ake199RnVsbFllYXJgXSgpLFxyXG4gICAgICAgICAgICAgICAgSCA9IGRhdGVbYCR7X31Ib3Vyc2BdKCksXHJcbiAgICAgICAgICAgICAgICBNID0gZGF0ZVtgJHtffU1pbnV0ZXNgXSgpLFxyXG4gICAgICAgICAgICAgICAgcyA9IGRhdGVbYCR7X31TZWNvbmRzYF0oKSxcclxuICAgICAgICAgICAgICAgIEwgPSBkYXRlW2Ake199TWlsbGlzZWNvbmRzYF0oKSxcclxuICAgICAgICAgICAgICAgIG8gPSB1dGMgPyAwIDogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpLFxyXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZCxcclxuICAgICAgICAgICAgICAgICAgICBkZDogcGFkKGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRkZDogZEYuaTE4bi5kYXlOYW1lc1tEXSxcclxuICAgICAgICAgICAgICAgICAgICBkZGRkOiBkRi5pMThuLmRheU5hbWVzW0QgKyA3XSxcclxuICAgICAgICAgICAgICAgICAgICBtOiBtICsgMSxcclxuICAgICAgICAgICAgICAgICAgICBtbTogcGFkKG0gKyAxKSxcclxuICAgICAgICAgICAgICAgICAgICBtbW06IGRGLmkxOG4ubW9udGhOYW1lc1ttXSxcclxuICAgICAgICAgICAgICAgICAgICBtbW1tOiBkRi5pMThuLm1vbnRoTmFtZXNbbSArIDEyXSxcclxuICAgICAgICAgICAgICAgICAgICB5eTogU3RyaW5nKHkpLnNsaWNlKDIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHl5eXk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgaDogSCAlIDEyIHx8IDEyLFxyXG4gICAgICAgICAgICAgICAgICAgIGhoOiBwYWQoSCAlIDEyIHx8IDEyKSxcclxuICAgICAgICAgICAgICAgICAgICBILFxyXG4gICAgICAgICAgICAgICAgICAgIEhIOiBwYWQoSCksXHJcbiAgICAgICAgICAgICAgICAgICAgTSxcclxuICAgICAgICAgICAgICAgICAgICBNTTogcGFkKE0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHMsXHJcbiAgICAgICAgICAgICAgICAgICAgc3M6IHBhZChzKSxcclxuICAgICAgICAgICAgICAgICAgICBsOiBwYWQoTCwgMyksXHJcbiAgICAgICAgICAgICAgICAgICAgTDogcGFkKEwgPiA5OSA/IE1hdGgucm91bmQoTCAvIDEwKSA6IEwpLFxyXG4gICAgICAgICAgICAgICAgICAgIHQ6IEggPCAxMiA/ICdhJyA6ICdwJyxcclxuICAgICAgICAgICAgICAgICAgICB0dDogSCA8IDEyID8gJ2FtJyA6ICdwbScsXHJcbiAgICAgICAgICAgICAgICAgICAgVDogSCA8IDEyID8gJ0EnIDogJ1AnLFxyXG4gICAgICAgICAgICAgICAgICAgIFRUOiBIIDwgMTIgPyAnQU0nIDogJ1BNJyxcclxuICAgICAgICAgICAgICAgICAgICBaOiB1dGMgPyAnVVRDJyA6IChTdHJpbmcoZGF0ZSkubWF0Y2godGltZXpvbmUpIHx8IFsnJ10pLnBvcCgpLnJlcGxhY2UodGltZXpvbmVDbGlwLCAnJyksXHJcbiAgICAgICAgICAgICAgICAgICAgbzogKG8gPiAwID8gJy0nIDogJysnKSArIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCksXHJcbiAgICAgICAgICAgICAgICAgICAgUzogWyd0aCcsICdzdCcsICduZCcsICdyZCddW2QgJSAxMCA+IDMgPyAwIDogKGQgJSAxMDAgLSBkICUgMTAgIT0gMTApICogZCAlIDEwXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtYXNrLnJlcGxhY2UodG9rZW4sICQwID0+ICgkMCBpbiBmbGFncyA/IGZsYWdzWyQwXSA6ICQwLnNsaWNlKDEsICQwLmxlbmd0aCAtIDEpKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgLy8gU29tZSBjb21tb24gZm9ybWF0IHN0cmluZ3NcclxuICAgIGRhdGVGb3JtYXQubWFza3MgPSB7XHJcbiAgICAgICAgZGVmYXVsdDogJ2RkZCBtbW0gZGQgeXl5eSBISDpNTTpzcycsXHJcbiAgICAgICAgc2hvcnREYXRlOiAnbS9kL3l5JyxcclxuICAgICAgICBtZWRpdW1EYXRlOiAnbW1tIGQsIHl5eXknLFxyXG4gICAgICAgIGxvbmdEYXRlOiAnbW1tbSBkLCB5eXl5JyxcclxuICAgICAgICBmdWxsRGF0ZTogJ2RkZGQsIG1tbW0gZCwgeXl5eScsXHJcbiAgICAgICAgc2hvcnRUaW1lOiAnaDpNTSBUVCcsXHJcbiAgICAgICAgbWVkaXVtVGltZTogJ2g6TU06c3MgVFQnLFxyXG4gICAgICAgIGxvbmdUaW1lOiAnaDpNTTpzcyBUVCBaJyxcclxuICAgICAgICBpc29EYXRlOiAneXl5eS1tbS1kZCcsXHJcbiAgICAgICAgaXNvVGltZTogJ0hIOk1NOnNzJyxcclxuICAgICAgICBpc29EYXRlVGltZTogJ3l5eXktbW0tZGRcXCdUXFwnSEg6TU06c3MnLFxyXG4gICAgICAgIGlzb1V0Y0RhdGVUaW1lOiAnVVRDOnl5eXktbW0tZGRcXCdUXFwnSEg6TU06c3NcXCdaXFwnJ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJbnRlcm5hdGlvbmFsaXphdGlvbiBzdHJpbmdzXHJcbiAgICBkYXRlRm9ybWF0LmkxOG4gPSB7XHJcbiAgICAgICAgZGF5TmFtZXM6IFtcclxuICAgICAgICAgICAgJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCcsXHJcbiAgICAgICAgICAgICdTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSdcclxuICAgICAgICBdLFxyXG4gICAgICAgIG1vbnRoTmFtZXM6IFtcclxuICAgICAgICAgICAgJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJyxcclxuICAgICAgICAgICAgJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxuXHJcbiAgICBjYWxsYmFjayhkYXRlRm9ybWF0KTtcclxufShkYXRlRm9ybWF0ID0+ICgodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnKSA/ICh0aGlzLmRhdGVGb3JtYXQgPSBkYXRlRm9ybWF0KSA6IChtb2R1bGUuZXhwb3J0cyA9IGRhdGVGb3JtYXQpKSkpO1xyXG4iLCJ2YXIgZGVmYXVsdExhbmcgPSAnZW4nO1xyXG4iXX0=
